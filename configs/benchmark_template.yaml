name: benchmark_template
description: Template preset for benchmarking extractors/matchers under fixed GSplat settings
expected_time: 20–35 minutes (depends on scene & GPU)

# ─────────────────────────────────────────────────────────────
# HLOC / SfM configuration
# ONLY change this block per experiment (extractor/matcher/etc.)
# ─────────────────────────────────────────────────────────────
sfm:
  # Pair generation (keep fixed across experiments for fairness)
  matching_method: retrieval            # --matching-method
  seq_overlap: 10                       # mostly ignored unless sequential
  seq_quadratic_overlap: false
  seq_loop_closure: true                # keep true for robustness
  num_matched: 20                       # keep fixed for fair comparisons

  # Global / local features (THIS is what you change per benchmark)
  global_extractor: netvlad             # keep fixed, or change systematically
  extractor: disk                       # <-- change per experiment
  matcher: disk-lightglue               # <-- change per experiment

  # SuperGlue knobs (ignored unless matcher=superglue)
  superglue_weights: outdoor
  sinkhorn_iterations: 50

  # Camera & backend
  camera_model: PINHOLE
  sfm_backend: glomap                   # keep fixed backend for fairness
  glomap_bin: glomap

  # Misc HLOC options
  vis: false
  keep_intermediates: false

  # Downsample factor for images used by GSplat
  data_factor: 8                        # fixed for all benchmarks

# ─────────────────────────────────────────────────────────────
# GSplat configuration
# KEEP THIS BLOCK IDENTICAL ACROSS ALL BENCHMARK RUNS
# ─────────────────────────────────────────────────────────────
gsplat:
  subcommand: mcmc
  data_factor: 8                        # same as sfm.data_factor
  max_steps: 30000                      # fixed number of steps
  eval_steps: [7000, 15000, 30000]
  save_ply: true
  save_steps: [30000]
  ply_steps: [30000]

  # viewer / video
  disable_viewer: true
  disable_video: true
  port: 8080

  # camera & scene scale
  camera_model: pinhole
  global_scale: 1.0
  normalize_world_space: true

  # optimisation / quality
  batch_size: 1
  steps_scaler: 1.0
  ssim_lambda: 0.2
  antialiased: true
  random_bkgd: true

  # SH / appearance
  sh_degree: 3
  sh_degree_interval: 1000
  init_type: sfm
  init_opa: 0.5
  init_scale: 0.1

  # learning rates
  means_lr: 0.00016
  scales_lr: 0.005
  opacities_lr: 0.05
  quats_lr: 0.001
  sh0_lr: 0.0025
  shN_lr: 0.000125

  # regularisation
  opacity_reg: 0.01
  scale_reg: 0.01

  # pose optimisation OFF for benchmarking (avoid extra source of variation)
  pose_opt: false
  pose_opt_lr: 1.0e-5
  pose_opt_reg: 1.0e-6
  pose_noise: 0.0

  # depth supervision OFF (to keep runs comparable if depth varies)
  depth_loss: false
  depth_lambda: 0.01

  # logging
  tb_every: 500
  tb_save_image: false
  lpips_net: alex

  # memory / performance tweaks
  packed: true
  sparse_grad: false
  visible_adam: false

  # MCMC densification strategy
  strategy:
    cap_max: 1000000
    noise_lr: 500000.0
    min_opacity: 0.005
    refine_start_iter: 500
    refine_stop_iter: 25000
    refine_every: 100
    verbose: true
